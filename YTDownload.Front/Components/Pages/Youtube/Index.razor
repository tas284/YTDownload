@page "/youtube"
@rendermode InteractiveServer
@inject IYoutubeService _service

<h3>Youtube Downloader</h3>
<p role="status">Informe a url do vídeo aqui:</p>


<div>
    <InputText id="url" @bind-Value="Url" class="form-control" placeholder="Informe aqui a url do vídeo..." style="display: inline; margin-right: 5px; width:70%;" />
    <button class="btn btn-outline-primary" @onclick="GetManifestInfo">Obter Informações</button>
    <button class="btn btn-outline-success" @onclick="SubmitSelection">Baixar</button>
</div>
<hr />
@if (Streams.Count == 0 && Searching)
{
    <p><em>Pesquisando...</em></p>
}
else
{
    <table class="table table-striped">
        <thead>
            <tr>
                <th></th>
                <td>Formato</td>
                <td>Video Codec</td>
                <td>Resolução</td>
                <td>Tamanho</td>
                <td>Audio</td>
                <td>Audio Codec</td>
            </tr>
        </thead>
        <tbody>
            @foreach (var stream in Streams)
            {
                <tr>
                    <td>
                        <input type="checkbox" @bind-value="stream.IsSelected" />
                    </td>
                    <td>@stream.ContainerName</td>
                    <td>@stream.VideoCodec</td>
                    <td>@stream.Resolution</td>
                    <td>@stream.Size.ToString() Mb</td>
                    <td>@stream.IsAudioOnly</td>
                    <td>@stream.AudioCodec</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private string Url { get; set; }
    public List<StreamViewModel> Streams = new();
    private bool Searching { get; set; }

    [Inject] IJSRuntime JSRuntime { get; set; }

    private async Task GetManifestInfo()
    {
        if (!string.IsNullOrEmpty(Url))
        {
            Searching = true;
            List<StreamManifestViewModel> streams = await _service.DownloadManifestInfo(Url);

            if (streams.Count > 0)
            {
                Streams.Clear();
                Streams.AddRange(streams.Select(s => new StreamViewModel(s.ContainerName, s.VideoCodec, s.Resolution, s.Size, s.IsAudioOnly, s.AudioCodec, s.Url)));
            }
            Searching = false;
        }
    }

    public async Task SubmitSelection()
    {
        var selecteds = Streams.Where(s => s.IsSelected);

        foreach (var selected in selecteds)
        {
            var input = Streams.Where(
                s => s.ContainerName == selected.ContainerName &&
                s.VideoCodec == selected.VideoCodec &&
                s.Resolution == selected.Resolution &&
                s.Size == selected.Size &&
                s.AudioCodec == selected.AudioCodec)
                .First();

            if (input != null)
            {
                var command = new DownloadCommand(input.Url, input.ContainerName, input.VideoCodec, input.Resolution, input.AudioCodec, input.IsAudioOnly);
                var filePath = await _service.Download(command);

                if (!string.IsNullOrEmpty(filePath))
                {
                    var fileUrl = $"/downloads/{Uri.EscapeDataString(Path.GetFileName(filePath))}";
                    await JSRuntime.InvokeVoidAsync("downloadFileFromPath", fileUrl);
                }
            }
        }
    }
}
